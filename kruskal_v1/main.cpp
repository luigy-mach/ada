#include <iostream>
#include "Grafo.h"
#include<fstream>
#include<stdlib.h>


#include "fibonacciHeap.h"

#define nulo -1
#define infinito 9999999
//------------------------------------------------------//
using namespace std;
//------------------------------------------------------//
struct Tarista{
    int origen;
    int destino;
    double costo;
};
//------------------------------------------------------//
void extraerMinimo(list<Tarista> & aristas,Tarista & minima);
void inicializar (Grafo<double> grafo,list<Tarista> & cola,int  arbol[])
{
//inicializa los arreglos distancia y padre y la lista de aristas (cola)
    list<int> vertices;
    list<Grafo<double>::Arco> adyacentes;
    grafo.devolverVertices(vertices);
    list<int>::const_iterator it_vert;
    for(it_vert = vertices.begin(); it_vert != vertices.end(); it_vert++)
    {
        grafo.devolverAdyacentes(*it_vert,adyacentes);
        arbol[*it_vert] = *it_vert;
        list<Grafo<double>::Arco>::const_iterator it_ady;
        for( it_ady = adyacentes.begin(); it_ady != adyacentes.end(); it_ady++)
            if (grafo.existeArco(*it_vert,it_ady->devolverAdyacente()))
            {
                Tarista arista;
                arista.origen = *it_vert;
                arista.destino = it_ady -> devolverAdyacente();
                arista.costo = it_ady -> devolverCosto();
                cola.push_front(arista);
            }
        adyacentes.clear();
    }
}
//------------------------------------------------------//

void mostrar(list<Tarista> solucion)
{
    list<Tarista>::const_iterator it;
    cout << "Arbol de minimo costo " << endl << endl;
    int suma = 0;
    for(it = solucion.begin(); it != solucion.end(); it++)
    {
        cout << "(" << it->origen << "," << it->destino << ") = " << it->costo << endl;
        suma = suma + it->costo;
    }
    cout << endl << "Costo = " << suma << endl;
}
//------------------------------------------------------//
bool mismo_arbol(int arbol[],int origen, int destino)
{
    if (arbol[origen] == arbol[destino])
        return true;
    return false;
}
//------------------------------------------------------//
void actualizar(int arbol[],int longitud,int origen,int destino)
{
    int n_arb = arbol[destino];
    for(int indice = 0; indice<longitud;indice++)
        if (arbol[indice] == n_arb)
            arbol[indice] = arbol[origen];

}
//------------------------------------------------------//
void extraerMinimd(list<Tarista> & aristas,Tarista & minima)
{
	/// fibonacci
    list<Tarista>::iterator it;
    list<Tarista>::iterator borrar;
    double min_costo = infinito;
    for(it = aristas.begin(); it != aristas.end(); it++)
        if (it->costo < min_costo)
        {
            borrar = it;
            min_costo = it->costo;
        }
     minima.origen = borrar->origen;
     minima.destino = borrar->destino;
     minima.costo = borrar->costo;
     aristas.erase(borrar);
}
//------------------------------------------------------//



void print_dot(Grafo<double>& grafo, list<int>& vertices_grafo, list<Tarista>& solucion)
{


/*

  
    subgraph cluster_Dertouzos {Dertouzos_icon[image="Dertouzos.png"];};
    subgraph cluster_Berners_Lee {Berners_Lee_icon[image="Berners_Lee.png"];};


   
    Dertouzos_icon -- Berners_Lee_icon;

}*/


		ofstream dot_file("mst.dot");
		dot_file << "graph D {\n" 
		//<< "       compound=true; \n" 
		<< "       size=\"2000,30\"; \n" 

		//<< "       ranksep=1.25; \n" 
		//--<< "  	   node [shape=plaintext, fontsize=16, label=""]; \n" 
		//<< "       bgcolor=white; \n" 
		//<< "       edge [arrowsize=1, color=black]; \n" 
		//<< "       graph[penwidth=0, labelloc=\"b\"]; \n"
		;

	list<int>::iterator v = vertices_grafo.begin();
	
	//cout << "Arbol de minimo costo DOT" << endl << endl;
	int i=0;
	while (v != vertices_grafo.end() )
	{
		dot_file <<"		subgraph "<< *v <<" {"<< *v <<"[image=\""<<grafo.dir[i] <<"\"];}; \n" ;
		v++;
		i++;
	}
	//<< "       /*------------------MST-----------------*/ \n";


	list<Tarista>::const_iterator it;
	int suma = 0;
	for(it = solucion.begin(); it != solucion.end(); it++)
	{
        	dot_file << it->origen << "--" << it->destino<<"\n";  //  << it->costo << endl;
        	suma = suma + it->costo;
	}
	


	dot_file << "}";
	cout << endl << "FIN " << suma << endl;
	//-----------------------------------


	
}

//------------------------------------------------------//


void kruskal( Grafo<double> & grafo, list<int>& vertices_grafo)
{
    list<Tarista> aristas;
    list<Tarista> solucion;
    int arbol[grafo.devolverLongitud()]; //cada vertice inicialmente tiene definido un arbol ( arbol = # de vertice)
    inicializar(grafo,aristas,arbol);
    Tarista minima;
    while (!aristas.empty())
    {
        extraerMinimo(aristas,minima);
        if (!mismo_arbol(arbol,minima.origen,minima.destino))
        {
            solucion.push_back(minima);
            actualizar(arbol,grafo.devolverLongitud(),minima.origen,minima.destino);
        }
    }
	cout<<"imprimiendo_ dot"<<endl;
    print_dot(grafo, vertices_grafo, solucion);
	cout<<"fin_ dot"<<endl;
}



void cargar_grafo(Grafo<double> &grafo)
{
ifstream f("lista_total.txt");
ifstream f2("distancias.txt");

int num_files,v1,v2;
double weight;
string cont;
f>>num_files;

for(int i=0;i<num_files;i++)
{

f>>cont;
grafo.dir.push_back(cont);
grafo.agregarVertice(i);
}
list<int> vertices;
 grafo.devolverVertices(vertices);
cout<< vertices.size()<<endl;
/*
    grafo.agregarVertice(0);
    grafo.agregarVertice(1);
    grafo.agregarVertice(2);
    grafo.agregarVertice(3);
    grafo.agregarVertice(4);
    grafo.agregarVertice(5);
    grafo.agregarVertice(6);
*/
int i=0;
while(f2>>v1>>v2>>weight && i<500)
{
	grafo.agregarArco(v1,v2,weight);
	i++;
}


/*

    grafo.agregarArco(3,0,5);
    grafo.agregarArco(0,3,5);
    grafo.agregarArco(2,4,5);
    grafo.agregarArco(4,2,5);
    grafo.agregarArco(3,5,6);
    grafo.agregarArco(5,3,6);
    grafo.agregarArco(0,1,7);
    grafo.agregarArco(1,0,7);
    grafo.agregarArco(1,2,8);
    grafo.agregarArco(2,1,8);
    grafo.agregarArco(5,4,8);
    grafo.agregarArco(4,5,8);
    grafo.agregarArco(1,3,9);
    grafo.agregarArco(3,1,9);
    grafo.agregarArco(4,6,9);
    grafo.agregarArco(6,4,9);
    grafo.agregarArco(5,6,11);
    grafo.agregarArco(6,5,11);
    grafo.agregarArco(3,4,15);
    grafo.agregarArco(4,3,15);
    grafo.agregarArco(1,4,7);
    grafo.agregarArco(4,1,7);
    cout << grafo;
*/
}
//------------------------------------------------------//
int main(){
    Grafo<double> grafo1;
    list<int> vertices;
   
    cargar_grafo(grafo1); 
    grafo1.devolverVertices(vertices);
    kruskal(grafo1,vertices);
}
//------------------------------------------------------//











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































void extraerMinimo(list<Tarista> & aristas,Tarista & minima)
{
    list<Tarista>::iterator it;
    list<Tarista>::iterator borrar;
    int min_costo = infinito;
    for(it = aristas.begin(); it != aristas.end(); it++)
        if (it->costo < min_costo)
        {
            borrar = it;
            min_costo = it->costo;
        }
     minima.origen = borrar->origen;
     minima.destino = borrar->destino;
     minima.costo = borrar->costo;
     aristas.erase(borrar);
}

